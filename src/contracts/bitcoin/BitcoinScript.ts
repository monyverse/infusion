import * as crypto from 'crypto';

/**
 * Bitcoin Script HTLC Implementation
 * Based on OP_CHECKLOCKTIMEVERIFY and OP_SHA256/OP_EQUALVERIFY
 */
export class BitcoinScriptHTLC {
  protected network: 'mainnet' | 'testnet';

  constructor(network: 'mainnet' | 'testnet' = 'testnet') {
    this.network = network;
  }

  /**
   * Generate HTLC Bitcoin Script
   * @param hashlock SHA256 hash of the preimage
   * @param recipientPubKey Recipient's public key (compressed)
   * @param senderPubKey Sender's public key (compressed)
   * @param locktime Unix timestamp for refund
   * @returns Bitcoin script as hex string
   */
  generateHTLCScript(
    hashlock: Buffer,
    recipientPubKey: Buffer,
    senderPubKey: Buffer,
    locktime: number
  ): string {
    // Convert locktime to little-endian 4-byte format
    const locktimeBuffer = Buffer.alloc(4);
    locktimeBuffer.writeUInt32LE(locktime, 0);

    // Script structure:
    // OP_IF
    //   OP_SHA256 <hashlock> OP_EQUALVERIFY
    //   <recipient_pubkey> OP_CHECKSIG
    // OP_ELSE
    //   <locktime> OP_CHECKLOCKTIMEVERIFY OP_DROP
    //   <sender_pubkey> OP_CHECKSIG
    // OP_ENDIF

    const script = [
      // OP_IF
      0x63,
      // OP_SHA256
      0xa8,
      // Push hashlock (32 bytes)
      0x20,
      ...hashlock,
      // OP_EQUALVERIFY
      0x88,
      // Push recipient public key (33 bytes for compressed)
      0x21,
      ...recipientPubKey,
      // OP_CHECKSIG
      0xac,
      // OP_ELSE
      0x67,
      // Push locktime (4 bytes)
      0x04,
      ...locktimeBuffer,
      // OP_CHECKLOCKTIMEVERIFY
      0xb1,
      // OP_DROP
      0x75,
      // Push sender public key (33 bytes for compressed)
      0x21,
      ...senderPubKey,
      // OP_CHECKSIG
      0xac,
      // OP_ENDIF
      0x68
    ];

    return Buffer.from(script).toString('hex');
  }

  /**
   * Generate P2WSH address from HTLC script
   * @param scriptHex HTLC script as hex string
   * @returns P2WSH address
   */
  generateP2WSHAddress(scriptHex: string): string {
    const script = Buffer.from(scriptHex, 'hex');
    const scriptHash = crypto.createHash('sha256').update(script).digest();
    
    // P2WSH version byte (0x00 for mainnet, 0x00 for testnet)
    const version = 0x00;
    
    // Combine version and script hash
    const combined = Buffer.concat([Buffer.from([version]), scriptHash]);
    
    // Base58Check encoding
    return this.base58CheckEncode(combined);
  }

  /**
   * Create withdrawal transaction data
   * @param utxo Input UTXO
   * @param recipientAddress Recipient address
   * @param amount Amount to send
   * @param secret Preimage secret
   * @param hashlock Hashlock
   * @param recipientPubKey Recipient public key
   * @param senderPubKey Sender public key
   * @param locktime Locktime
   * @param fee Transaction fee
   * @returns Transaction data
   */
  createWithdrawalTransactionData(
    utxo: {
      txid: string;
      vout: number;
      value: number;
    },
    recipientAddress: string,
    amount: number,
    secret: Buffer,
    hashlock: Buffer,
    recipientPubKey: Buffer,
    senderPubKey: Buffer,
    locktime: number,
    fee: number = 1000
  ): {
    inputTxid: string;
    inputVout: number;
    outputAddress: string;
    outputAmount: number;
    witness: string[];
  } {
    // Create witness for withdrawal (redeem path)
    const witness = [
      // Signature (placeholder - would be generated by signing)
      '00',
      // Recipient public key
      recipientPubKey.toString('hex'),
      // Preimage
      secret.toString('hex'),
      // Script (full HTLC script)
      this.generateHTLCScript(hashlock, recipientPubKey, senderPubKey, locktime)
    ];

    return {
      inputTxid: utxo.txid,
      inputVout: utxo.vout,
      outputAddress: recipientAddress,
      outputAmount: amount - fee,
      witness
    };
  }

  /**
   * Create refund transaction data
   * @param utxo Input UTXO
   * @param senderAddress Sender address
   * @param amount Amount to refund
   * @param hashlock Hashlock
   * @param recipientPubKey Recipient public key
   * @param senderPubKey Sender public key
   * @param locktime Locktime
   * @param fee Transaction fee
   * @returns Transaction data
   */
  createRefundTransactionData(
    utxo: {
      txid: string;
      vout: number;
      value: number;
    },
    senderAddress: string,
    amount: number,
    hashlock: Buffer,
    recipientPubKey: Buffer,
    senderPubKey: Buffer,
    locktime: number,
    fee: number = 1000
  ): {
    inputTxid: string;
    inputVout: number;
    outputAddress: string;
    outputAmount: number;
    witness: string[];
  } {
    // Create witness for refund path
    const witness = [
      // Signature (placeholder - would be generated by signing)
      '00',
      // Sender public key
      senderPubKey.toString('hex'),
      // Empty string (false condition for OP_IF)
      '',
      // Script (full HTLC script)
      this.generateHTLCScript(hashlock, recipientPubKey, senderPubKey, locktime)
    ];

    return {
      inputTxid: utxo.txid,
      inputVout: utxo.vout,
      outputAddress: senderAddress,
      outputAmount: amount - fee,
      witness
    };
  }

  /**
   * Generate secret and hashlock
   * @returns Object with secret and hashlock
   */
  generateSecretAndHashlock(): { secret: Buffer; hashlock: Buffer } {
    const secret = crypto.randomBytes(32);
    const hashlock = crypto.createHash('sha256').update(secret).digest();
    return { secret, hashlock };
  }

  /**
   * Generate hashlock from secret
   * @param secret Secret preimage
   * @returns Hashlock
   */
  generateHashlock(secret: Buffer): Buffer {
    return crypto.createHash('sha256').update(secret).digest();
  }

  /**
   * Verify secret against hashlock
   * @param secret Secret preimage
   * @param hashlock Hashlock to verify against
   * @returns True if secret matches hashlock
   */
  verifySecret(secret: Buffer, hashlock: Buffer): boolean {
    const computedHashlock = this.generateHashlock(secret);
    return computedHashlock.equals(hashlock);
  }

  /**
   * Base58Check encoding
   * @param data Data to encode
   * @returns Base58Check encoded string
   */
  private base58CheckEncode(data: Buffer): string {
    // This is a simplified implementation
    // In production, you'd use a proper base58 library
    const alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    let num = BigInt('0x' + data.toString('hex'));
    let str = '';
    
    while (num > 0) {
      str = alphabet[Number(num % 58n)] + str;
      num = num / 58n;
    }
    
    // Add leading zeros
    for (let i = 0; i < data.length && data[i] === 0; i++) {
      str = '1' + str;
    }
    
    return str;
  }

  /**
   * Get network parameters
   * @returns Network parameters
   */
  getNetworkParams(): {
    name: string;
    magic: number;
    port: number;
    dnsSeeds: string[];
    genesisBlock: string;
  } {
    if (this.network === 'mainnet') {
      return {
        name: 'Bitcoin Mainnet',
        magic: 0xd9b4bef9,
        port: 8333,
        dnsSeeds: [
          'seed.bitcoin.sipa.be',
          'dnsseed.bluematt.me',
          'dnsseed.bitcoin.dashjr.org',
          'seed.bitcoinstats.com',
          'seed.bitcoin.jonasschnelli.ch',
          'seed.btc.petertodd.org'
        ],
        genesisBlock: '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f'
      };
    } else {
      return {
        name: 'Bitcoin Testnet',
        magic: 0x0709110b,
        port: 18333,
        dnsSeeds: [
          'testnet-seed.bitcoin.jonasschnelli.ch',
          'seed.tbtc.petertodd.org',
          'seed.testnet.bitcoin.sprovoost.nl',
          'testnet-seed.bluematt.me'
        ],
        genesisBlock: '000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943'
      };
    }
  }
}

/**
 * Litecoin HTLC implementation
 */
export class LitecoinScriptHTLC extends BitcoinScriptHTLC {
  constructor(network: 'mainnet' | 'testnet' = 'testnet') {
    super(network);
  }

  getNetworkParams(): {
    name: string;
    magic: number;
    port: number;
    dnsSeeds: string[];
    genesisBlock: string;
  } {
    if (this.network === 'mainnet') {
      return {
        name: 'Litecoin Mainnet',
        magic: 0xdbb6c0fb,
        port: 9333,
        dnsSeeds: [
          'seed-a.litecoin.loshan.co.uk',
          'dnsseed.thrasher.io',
          'dnsseed.litecointools.com',
          'dnsseed.litecoinpool.org'
        ],
        genesisBlock: '12a765e31ffd4059bada1e25190f6e98c99d9714d334efa41a195a7e7e04bfe2'
      };
    } else {
      return {
        name: 'Litecoin Testnet',
        magic: 0xf1c8d2fd,
        port: 19335,
        dnsSeeds: [
          'testnet-seed.litecointools.com',
          'seed-b.litecoin.loshan.co.uk',
          'dnsseed-testnet.thrasher.io'
        ],
        genesisBlock: 'f5ae71e26c74beacc88382716a9c9a0bc6ae63e7e68ab5d2487760c5c79b9449'
      };
    }
  }
}

/**
 * Bitcoin Cash HTLC implementation
 */
export class BitcoinCashScriptHTLC extends BitcoinScriptHTLC {
  constructor(network: 'mainnet' | 'testnet' = 'testnet') {
    super(network);
  }

  getNetworkParams(): {
    name: string;
    magic: number;
    port: number;
    dnsSeeds: string[];
    genesisBlock: string;
  } {
    if (this.network === 'mainnet') {
      return {
        name: 'Bitcoin Cash Mainnet',
        magic: 0xe3e1f3e8,
        port: 8333,
        dnsSeeds: [
          'seed.bitcoinabc.org',
          'seed-abc.bitcoinforks.org',
          'btccash-seeder.bitcoinunlimited.info',
          'seed.bitprim.org',
          'seed.deadalnix.me',
          'seeder.criptolayer.net'
        ],
        genesisBlock: '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f'
      };
    } else {
      return {
        name: 'Bitcoin Cash Testnet',
        magic: 0xf4e5f3f4,
        port: 18333,
        dnsSeeds: [
          'testnet-seed.bitcoinabc.org',
          'testnet-seed-abc.bitcoinforks.org',
          'testnet-seed.bitprim.org',
          'testnet-seed.deadalnix.me'
        ],
        genesisBlock: '000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943'
      };
    }
  }
} 